use crate::types::*;
use crate::Transposition;
use core::ops::{Mul, Not};
use std::convert::From;
use std::fmt;

// Imports used purely to prevent lots of boiler plate code in the documentation.  These won't be
// registered by the compiler, but we can suppress errors on just these imports so that we don't
// lose crate-wide compiler warnings.
#[allow(unused_imports)]
use crate::{Row, Touch};

/// In BellMetal, a `Change` represents an owned permutation, and is designed for one-off operations
/// where performance is not critical, since they will always have to be allocated on the heap.
/// However, because of this they can offer easy functionality that isn't possible using just
/// borrowed slices or [Row]s.
///
/// In BellMetal, there are two ways to represent permutations, roughly similar how the standard
/// library contains both [String] and [&str](str) for storing strings.  BellMetal has `Change` and
/// [Row] respectively, were `Change`s are heap-allocated owned permutations, and Rows are internally
/// references to a single row owned by a [Touch].  However, there is a subtle difference between this
/// and Rust strings, since it is not possible to convert a `Change` into a [Row] as [Row]s contain
/// more information derived from the [Touch] that they are generated by.
///
/// Both of these implement the trait [Transposition], which contains all the operations that are general to
/// permutations which include arithmetic operations, allocation-free tests for rounds or cyclicness,
/// and parity calculations.  However, by their nature, [Row]s are immutable because editing them
/// would change the underlying [Touch] which would lead to undefined behaviour.  Therefore, any
/// operations that require mutating permutations (like copying one `Change` into another to avoid
/// heap allocations) will only work on `Change`s, and are not implemented in [Transposition].
///
/// # Examples
/// ```
/// use bellmetal::Change;
///
/// let cyclic_part_head = Change::from("17823456");
/// let some_change = Change::from("43215678");
///
/// assert_eq!(cyclic_part_head * some_change, Change::from("28713456"));
/// ```
#[derive(Hash, PartialOrd, Ord, Eq, PartialEq, Clone)]
pub struct Change {
    seq: Vec<Bell>,
}

impl Change {
    /// Produces an empty `Change` (a `Change` with no [Bell]s).  This is used when a function will
    /// overwrite the contents of a `Change`, but you don't want to populate the `Change` with
    /// something that will be trashed by that function.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, Stage};
    ///
    /// let mut change = Change::empty();
    ///
    /// assert_eq!(change.stage(), Stage::from(0));
    ///
    /// Change::from("45678123").multiply_into(&Change::from("87651234"), &mut change);
    ///
    /// assert_eq!(change, Change::from("32184567"));
    /// ```
    pub fn empty() -> Change {
        Change {
            seq: Vec::with_capacity(0),
        }
    }

    /// Returns a `Change` representing rounds on a given [Stage].
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, Stage};
    ///
    /// assert_eq!(Change::rounds(Stage::MINOR), Change::from("123456"));
    /// assert_eq!(Change::rounds(Stage::MAJOR), Change::from("12345678"));
    /// assert_eq!(Change::rounds(Stage::CATERS), Change::from("123456789"));
    /// ```
    pub fn rounds(stage: Stage) -> Change {
        Change::from_iterator((0..stage.as_usize()).map(|x| Bell::from(x)))
    }

    /// Creates a new `Change`, given a vector of [Bell]s that it should contain.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, Bell};
    ///
    /// let bell_vec = vec![Bell::from('1'), Bell::from('2'), Bell::from('4'), Bell::from('3')];
    ///
    /// assert_eq!(Change::new(bell_vec), Change::from("1243"));
    /// ```
    pub fn new(bell_vec: Vec<Bell>) -> Change {
        Change { seq: bell_vec }
    }

    /// Creates a `Change` from an [Iterator] of [Bell]s.  The iterator must terminate, otherwise
    /// this will copy all the [Bell]s into memory and never terminate.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, Bell};
    ///
    /// let bell_vec = vec![Bell::from('1'), Bell::from('2'), Bell::from('4'), Bell::from('3')];
    ///
    /// assert_eq!(Change::from_iterator(bell_vec.iter().copied()), Change::from("1243"));
    /// ```
    pub fn from_iterator(iter: impl Iterator<Item = Bell>) -> Change {
        let mut c = Change::empty();

        c.overwrite_from_iterator(iter);

        c
    }

    /// Gets the [Stage] a given `Change`.
    ///
    /// # Examples
    /// ```
    /// use bellmetal::{Change, Stage};
    ///
    /// assert_eq!(Change::from("14867253").stage(), Stage::MAJOR);
    /// ```
    pub fn stage(&self) -> Stage {
        Stage::from(self.seq.len())
    }

    /// Returns a mutable slice from the underlying representation of a given `Change`.  This is
    /// designed mainly for internal use - if you really want to modify `Change`s then
    /// [set_bell](Change::set_bell) is a safer (but marginally slower) way to do so.  However,
    /// sometimes you just want as much speed as possible and know exactly what you're doing in
    /// which case you should use this.
    ///
    /// # Examples
    /// ```
    /// use bellmetal::{Bell, Change};
    ///
    /// let mut c = Change::from("12345678");
    ///
    /// let mut slice = c.mut_slice();
    /// slice[0] = Bell::from('2');
    /// slice[1] = Bell::from('1');
    ///
    /// assert_eq!(c, Change::from("21345678"));
    /// ```
    pub fn mut_slice(&mut self) -> &mut [Bell] {
        &mut self.seq
    }

    /// Multiplies this `Change` by another [Transposition].  This is the same as using the `*`
    /// operator except that this can borrow its arguments and so doesn't require `Clone`ing
    /// `Change`s.
    ///
    /// This is coded such that `a * b` or `a.multiply(b)` will mean "Suppose I have a touch that
    /// takes me from rounds to `a` and then after ring that I ring a touch that takes me from
    /// rounds to `b`.  The overall effect of the combination of these touches is `a * b`.  Note that
    /// this is opposite to how permutation multiplication works when represented as matrices.
    ///
    /// # Examples
    /// ```
    /// use bellmetal::Change;
    ///
    /// let cyclic_part_head = Change::from("17823456");
    /// let some_change = Change::from("43215678");
    ///
    /// assert_eq!(cyclic_part_head.multiply(&some_change), Change::from("28713456"));
    /// ```
    pub fn multiply(&self, rhs: &impl Transposition) -> Change {
        let mut c = Change::empty();

        self.multiply_into(rhs, &mut c);

        c
    }

    /// Overwrites a [Bell] in a given [Place] in a given `Change`.
    ///
    /// # Examples
    /// ```
    /// use bellmetal::{Bell, Place, Change};
    ///
    /// let mut c = Change::from("12345678");
    ///
    /// c.set_bell(Place::from(0), Bell::from('2'));
    /// c.set_bell(Place::from(1), Bell::from('1'));
    ///
    /// assert_eq!(c, Change::from("21345678"));
    /// ```
    pub fn set_bell(&mut self, place: Place, bell: Bell) {
        self.seq[place.as_usize()] = bell;
    }

    /// Multiplies a given `Change` with an iterator of [Bell]s (see [Change::multiply] for more
    /// details about how multiplication of permutations works).  This is the same as
    /// [multiply_iterator](Change::transfigure_iterator), except that this will return a `Change`
    /// rather than another iterator.
    ///
    /// Conceptually, this is treating the [Bell]s of the iterator as the place in this `Change`
    /// where the output [Bell] should come from.  Therefore, this has no requirement that the
    /// iterator represents a permutation - it could well contain duplicate [Bell]s, in which case
    /// the output will also contain duplicate [Bell]s in the same locations.
    ///
    /// # Examples
    /// ```
    /// use bellmetal::{Change, Transposition};
    ///
    /// let part_head = Change::from("56781234");
    ///
    /// assert_eq!(
    ///     part_head.multiply_iterator(Change::from("321321").iter()),
    ///     Change::from("765765")
    /// );
    /// ```
    pub fn multiply_iterator(&self, rhs: impl Iterator<Item = Bell>) -> Change {
        Change {
            seq: self.transfigure_iterator(rhs).collect(),
        }
    }

    /// Multiplies a given `Change` with an iterator of [Bell]s (see [Change::multiply] for more
    /// details about how multiplication of permutations works).  This is the same as
    /// [multiply_iterator](Change::multiply_iterator), except that this will return another
    /// iterator, rather than a `Change`.
    ///
    /// Conceptually, this is treating the [Bell]s of the iterator as the place in this `Change`
    /// where the output [Bell] should come from.  Therefore, this has no requirement that the
    /// iterator represents a permutation - it could well contain duplicate [Bell]s, in which case
    /// the output will also contain duplicate [Bell]s in the same locations.
    ///
    /// # Examples
    /// ```
    /// use bellmetal::{Bell, Change, Transposition};
    ///
    /// let c = Change::from("321");
    /// let part_head = Change::from("56781234");
    ///
    /// let mut new_iterator = part_head.transfigure_iterator(c.iter());
    ///
    /// assert_eq!(new_iterator.next(), Some(Bell::from('7')));
    /// assert_eq!(new_iterator.next(), Some(Bell::from('6')));
    /// assert_eq!(new_iterator.next(), Some(Bell::from('5')));
    /// assert_eq!(new_iterator.next(), None);
    /// ```
    pub fn transfigure_iterator<'a>(
        &'a self,
        rhs: impl Iterator<Item = Bell> + 'a,
    ) -> impl Iterator<Item = Bell> + 'a {
        rhs.map(move |b| self.seq[b.as_usize()])
    }

    /// Multiplies this `Change` on to the end of the argument, and copies the result into another
    /// `Change` to avoid heap allocations.  Note that the argument is used on the **left** hand side
    /// of the multiplication.
    ///
    /// # Panics
    /// Panics if `lhs` is doesn't have the same [Stage] as this `Change`.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let part_head = Change::from("34567812");
    /// let example_change = Change::from("43215786");
    /// let mut output_change = Change::empty();
    ///
    /// example_change.pre_multiply_into(&part_head, &mut output_change);
    ///
    /// assert_eq!(output_change, Change::from("65437128"));
    /// ```
    pub fn pre_multiply_into(&self, lhs: &impl Transposition, into: &mut Change) {
        if self.stage() != lhs.stage() {
            panic!("Can't use transpositions of different stages!");
        }

        into.seq.clear();

        for i in 0..self.stage().as_usize() {
            into.seq
                .push(lhs.bell_at(Place::from(self.seq[i].as_number())));
        }
    }

    /// Multiplies this `Change` by an iterator, and copies the result into another `Change` to
    /// avoid heap allocations.  Same as [multiply_iterator](Change::multiply_iterator), except
    /// that it will avoid allocating a new `Change` on the heap if an old one can be reused.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Change};
    ///
    /// let part_head = Change::from("34567812");
    /// let bells = [Bell::from('1'), Bell::from('3'), Bell::from('2')];
    /// let mut output_change = Change::empty();
    ///
    /// part_head.multiply_iterator_into(bells.iter().cloned(), &mut output_change);
    ///
    /// assert_eq!(output_change, Change::from("354"));
    /// ```
    pub fn multiply_iterator_into(&self, rhs: impl Iterator<Item = Bell>, into: &mut Change) {
        into.overwrite_from_iterator(self.transfigure_iterator(rhs));
    }

    /// Multiplies this `Change` by a [Transposition], and copies the result into another `Change` to
    /// avoid heap allocations.  Same as [multiply](Change::multiply), except that it will avoid
    /// allocating a new `Change` on the heap if an old one can be reused.
    ///
    /// # Panics
    /// Panics if `rhs` doesn't have the same [Stage] as this `Change`.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Change};
    ///
    /// let part_head = Change::from("34567812");
    /// let some_change = Change::from("23456187");
    /// let mut output_change = Change::empty();
    ///
    /// part_head.multiply_into(&some_change, &mut output_change);
    ///
    /// assert_eq!(output_change, Change::from("45678321"));
    /// ```
    pub fn multiply_into(&self, rhs: &impl Transposition, into: &mut Change) {
        if self.stage() != rhs.stage() {
            panic!("Can't use transpositions of different stages!");
        }

        into.seq.clear();

        for i in 0..self.stage().as_usize() {
            into.seq
                .push(self.seq[rhs.bell_at(Place::from(i)).as_usize()]);
        }
    }

    /// Multiplies this `Change` by the inversion of a [Transposition], without creating an
    /// intermediate `Change`.
    ///
    /// # Panics
    /// Panics if `rhs` doesn't have the same [Stage] as this `Change`.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Change};
    ///
    /// let part_head = Change::from("34567812");
    /// let some_change = Change::from("23456187");
    ///
    /// assert_eq!(
    ///     part_head.multiply_inverse(&some_change),
    ///     Change::from("83456721")
    /// );
    /// ```
    pub fn multiply_inverse(&self, rhs: &impl Transposition) -> Change {
        let mut change = Change::rounds(self.stage());

        self.multiply_inverse_into(rhs, &mut change);

        change
    }

    /// Multiplies this `Change` by the inversion of a [Transposition], and copies the result into
    /// another `Change` to without any heap allocations.  Same as [multiply](Change::multiply), except
    /// that it will avoid allocating a new `Change` on the heap if an old one can be reused.
    ///
    /// # Panics
    /// Panics if `rhs` doesn't have the same [Stage] as this `Change`.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Change};
    ///
    /// let part_head = Change::from("34567812");
    /// let some_change = Change::from("23456187");
    /// let mut output_change = Change::empty();
    ///
    /// part_head.multiply_inverse_into(&some_change, &mut output_change);
    ///
    /// assert_eq!(output_change, Change::from("83456721"));
    /// ```
    pub fn multiply_inverse_into(&self, rhs: &impl Transposition, into: &mut Change) {
        if self.stage() != rhs.stage() {
            panic!("Can't use transpositions of different stages!");
        }

        let stage = self.stage().as_usize();

        while into.stage().as_usize() < stage {
            into.seq.push(Bell::from(0));
        }

        if into.stage().as_usize() > stage {
            into.seq.truncate(stage);
        }

        for i in 0..stage {
            into.seq[rhs.bell_at(Place::from(i)).as_usize()] = self.seq[i];
        }
    }

    /// Replaces the contents of this `Change` with the permutation represented by `string`.  Doesn't
    /// enforce that `string` represents a permutation of the same [Stage] as `self`, so this can be
    /// used on any `Change` (even empty ones).
    ///
    /// # Panics
    /// Panics if `string` contains any characters that don't represent [Bell]s.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Stage, Change};
    ///
    /// let mut c = Change::rounds(Stage::ROYAL);
    ///
    /// c.overwrite_from_string("1357924680");
    ///
    /// assert_eq!(c, Change::from("1357924680"));
    ///
    /// c.overwrite_from_string("123456");
    ///
    /// assert_eq!(c.stage(), Stage::MINOR);
    ///
    /// assert_eq!(c, Change::rounds(Stage::MINOR));
    /// ```
    pub fn overwrite_from_string(&mut self, string: &str) {
        self.seq.clear();
        self.seq.reserve(string.len());

        for c in string.chars() {
            self.seq.push(Bell::from(c));
        }
    }

    /// Replaces the contents of this `Change` with the contents of `iter`.  As with
    /// [overwrite_from_string](Change::overwrite_from_string), it will change the [Stage] of this
    /// `Change` to be the same as the length of the iterator.  This will hang forever if the
    /// iterator is infinite.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Stage, Change};
    ///
    /// let mut c = Change::rounds(Stage::ROYAL);
    ///
    /// c.overwrite_from_iterator(
    ///     [Bell::from('1'), Bell::from('2'), Bell::from('4'), Bell::from('3')]
    ///         .iter()
    ///         .cloned()
    /// );
    ///
    /// assert_eq!(c.stage(), Stage::MINIMUS);
    ///
    /// assert_eq!(c, Change::from("1243"));
    /// ```
    pub fn overwrite_from_iterator(&mut self, iter: impl Iterator<Item = Bell>) {
        self.seq.clear();
        self.seq.extend(iter);
    }

    /// Replaces the contents of this `Change` with the contents of `slice`.  As with
    /// [overwrite_from_string](Change::overwrite_from_string), this doesn't enforce that the
    /// stages are the same.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Stage, Change};
    ///
    /// let mut c = Change::rounds(Stage::ROYAL);
    ///
    /// c.overwrite_from_slice(
    ///     &[Bell::from('1'), Bell::from('2'), Bell::from('4'), Bell::from('3')]
    /// );
    ///
    /// assert_eq!(c.stage(), Stage::MINIMUS);
    ///
    /// assert_eq!(c, Change::from("1243"));
    /// ```
    pub fn overwrite_from_slice(&mut self, slice: &[Bell]) {
        self.overwrite_from_iterator(slice.iter().cloned());
    }

    /// Replaces the contents of this `Change` with the contents of the given [Transposition].  As with
    /// [overwrite_from_string](Change::overwrite_from_string), this doesn't enforce that the
    /// stages are the same.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Stage, Change};
    ///
    /// let mut c = Change::rounds(Stage::ROYAL);
    ///
    /// c.overwrite_from(&Change::from("145623"));
    ///
    /// assert_eq!(c.stage(), Stage::MINOR);
    ///
    /// assert_eq!(c, Change::from("145623"));
    /// ```
    pub fn overwrite_from(&mut self, other: &impl Transposition) {
        self.overwrite_from_slice(other.slice());
    }

    /// Raises the contents of this `Change` to a given exponent.  This uses an `O(|n|)` algorithm
    /// of repeatedly multiplying the `Change` with itself, which is faster than the (otherwise better)
    /// `O(log|n|)` method of repeated squaring for small values of the exponent.  Also allocates
    /// on the heap in order to store the intermediate values.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Stage, Change};
    ///
    /// let cyclic_part_end = Change::from("81234567");
    ///
    /// assert_eq!(cyclic_part_end.pow(-3), Change::from("45678123"));
    /// assert_eq!(cyclic_part_end.pow(2), Change::from("78123456"));
    /// assert_eq!(cyclic_part_end.pow(0), Change::rounds(Stage::MAJOR));
    /// ```
    pub fn pow(&self, exponent: isize) -> Change {
        // Return rounds if the exponent is 0
        if exponent == 0 {
            return Change::rounds(self.stage());
        }

        // Create an accumulator to repeatedly multiply this change into
        let mut accumulator = ChangeAccumulator::new(self.stage());

        if exponent > 0 {
            for _ in 0..exponent as usize {
                accumulator.accumulate(self);
            }
        } else {
            for _ in 0..(-exponent) as usize {
                accumulator.accumulate_inverse(self);
            }
        }

        // Return the total value stored by the accumulator (cloned to stop the value being freed)
        accumulator.total().clone()
    }

    /// Inverts this `Change`, so that it represents the same `Change` but starting from the change
    /// like `18765432`.  This as the same effect as as premultiplying by `18765432` (or the equivalent
    /// on the correct [Stage]), or swapping the `2` with the tenor, the `3` with the `n - 1`,
    /// etc.  Same as [in_place_inverse](Change::in_place_inverse), except that the treble is always left
    /// unaffected by the transformation.
    ///
    /// This is useful in making canonicalisation functions for proving palendromic multiparts, where
    /// the symmetry point is exactly half way between rounds and the "Before" lead end.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let mut c1 = Change::from("13287654");
    /// c1.in_place_fixed_treble_inverse();
    /// assert_eq!(c1, Change::from("17823456"));
    ///
    /// let mut c2 = Change::from("3456127890");
    /// c2.in_place_fixed_treble_inverse();
    /// assert_eq!(c2, Change::from("9876105432"));
    /// ```
    pub fn in_place_fixed_treble_inverse(&mut self) {
        let stage = self.seq.len();

        for i in 0..stage {
            // Check if the bell is not the treble
            if self.seq[i] != Bell::from(0) {
                // Calculate the new bell
                self.seq[i] = Bell::from(stage - self.seq[i].as_usize());
            }
        }
    }

    /// Inverts this `Change`, so that it represents the same `Change` but starting from
    /// backrounds.  This is the same as swapping the treble with the tenor, the `2` with the `n - 1`,
    /// etc.
    ///
    /// This is useful in making canonicalisation functions for proving palendromic multiparts, where
    /// the symmetry point is exactly half way between rounds and the "Before" lead end.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let mut c1 = Change::from("13287654");
    /// c1.in_place_inverse();
    /// assert_eq!(c1, Change::from("86712345"));
    ///
    /// let mut c2 = Change::from("3456127890");
    /// c2.in_place_inverse();
    /// assert_eq!(c2, Change::from("8765094321"));
    /// ```
    pub fn in_place_inverse(&mut self) {
        let stage = self.seq.len();

        for i in 0..stage {
            self.seq[i] = Bell::from(stage - 1 - self.seq[i].as_usize());
        }
    }

    /// Rotates this `Change` cyclically by `amount` steps, with the treble affected.
    ///
    /// For example, if `amount` is `2` and the [Stage] is major then `3` will become `3 + 2 = 5 (mod 8)`,
    /// and `7` will become `7 + 2 = 9 = 1 (mod 8)`.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let mut c1 = Change::from("1654327890");
    /// c1.in_place_full_cyclic_rotate(4);
    /// assert_eq!(c1, Change::from("5098761234"));
    /// ```
    pub fn in_place_full_cyclic_rotate(&mut self, amount: usize) {
        let stage = self.seq.len();

        for i in 0..stage {
            self.seq[i] = Bell::from((self.seq[i].as_usize() + amount) % stage);
        }
    }

    /// Rotates this `Change` cyclically by `amount` steps, while leaving the treble unaffected.
    /// Same as (in_place_full_cyclic_rotate)[Change::in_place_full_cyclic_rotate], except that
    /// this leaves the treble where it is, and only rotates the remaining [Bell]s.
    ///
    /// For example, if `amount` is `2` and the [Stage] is (Major)[Stage::MAJOR] then `3` will become `5`,
    /// and `7` will become `2`.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let mut c1 = Change::from("1654327890");
    /// c1.in_place_full_cyclic_rotate(4);
    /// assert_eq!(c1, Change::from("5098761234"));
    /// ```
    pub fn in_place_fixed_treble_cyclic_rotate(&mut self, amount: usize) {
        let stage = self.seq.len();

        for i in 0..stage {
            // Only rotate the bells if not the treble
            if self.seq[i] != Bell::from(0) {
                let mut new_bell = self.seq[i].as_usize() + amount;

                // Repeatedly wrap until we get a bell in the correct range
                while new_bell >= stage {
                    new_bell = new_bell + 1 - stage;
                }

                self.seq[i] = Bell::from(new_bell);
            }
        }
    }

    /// Reverses the `Change` front-to-back.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let mut c1 = Change::from("3456127890");
    /// c1.in_place_reverse();
    /// assert_eq!(c1, Change::from("0987216543"));
    /// ```
    pub fn in_place_reverse(&mut self) {
        let stage = self.seq.len();

        // Repeatedly swap pairs of values, missing out the middle value if the stage is odd
        for i in 0..stage / 2 {
            let tmp = self.seq[i];
            self.seq[i] = self.seq[stage - 1 - i];
            self.seq[stage - 1 - i] = tmp;
        }
    }

    /// Hashes the change into the range `0..(stage)!`, but in the process it will destroy the
    /// contents of `Change`.  In fact, it cannot be guarunteed that this function leaves this
    /// `Change` representing a valid permutation.
    ///
    /// Useful when proof checking on lower numbers, by creating a blank
    /// table with a space for every possible change and then iterating over every row, filling in
    /// the corresponding slot on the table.
    ///
    /// # Example
    /// ```
    /// use bellmetal::Change;
    ///
    /// let mut c = Change::from("14723865");
    ///
    /// assert_eq!(c.destructive_hash(), 26939);
    /// assert_ne!(c, Change::from("14723865"));
    /// ```
    pub fn destructive_hash(&mut self) -> usize {
        let stage = self.seq.len();

        // Initialise multiplier to (stage - 1)!
        let mut multiplier = 1;
        for i in 1..stage {
            multiplier *= i;
        }

        let mut i = stage - 1;
        let mut hash = 0;

        // Invariant:
        //   1) self.seq[..i] is a valid permutation
        //   2) multiplier = i!
        //   3) destructive_hash(self.seq[..i]) + hash = x
        //           where x is the output of the function
        while i > 0 {
            // Iterate to find the index of the bell represented by `i`
            for j in 0..stage {
                // Check if we've found the right bell
                if self.seq[j] == Bell::from(i) {
                    // Add the bell's index into our hash
                    hash += j * multiplier;

                    // Here, we could (and should for clarity) swap `self.seq[j]` and
                    // `self.seq[i]`, but since `seq[i]` will never be read, it is a waste of time
                    // setting it to any particular value.
                    self.seq[j] = self.seq[i];

                    // Break the loop, since the inner loop has done its work already
                    break;
                }
            }

            // Update both `i` and `multiplier` to preserve Invariant #2
            multiplier /= i;
            i -= 1;
        }

        // Return the accumulated hash value
        hash
    }
}

impl Transposition for Change {
    fn slice(&self) -> &[Bell] {
        &self.seq
    }
}

impl fmt::Debug for Change {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut s = String::with_capacity(self.stage().as_usize());

        for b in &self.seq {
            s.push(b.as_char());
        }

        write!(f, "<{}>", s)
    }
}

impl Mul for Change {
    type Output = Self;

    fn mul(self, rhs: Change) -> Self {
        self.multiply(&rhs)
    }
}

impl Not for Change {
    type Output = Self;

    fn not(self) -> Self {
        self.inverse()
    }
}

impl From<&str> for Change {
    /// Converts a string of valid `Bell` names into the `Change` represented by it.
    fn from(s: &str) -> Change {
        let mut change = Change::empty();

        change.overwrite_from_string(s);

        change
    }
}

/// A `ChangeAccumulator` is a struct that can be used to repeatedly accumulate [Change]s, without
/// allocating any memory on the heap every multiplication.  However, since the stage of the
/// changes aren't known at compile time, there will be two heap allocations when the
/// `ChangeAccumulator` is instantiated.
///
/// `ChangeAccumulator` is used heavily in this library for tasks that need
/// a lot of repeated permutating, for example storing lead heads whilst generating touches.
///
/// # Example
/// ```
/// use bellmetal::{Change, ChangeAccumulator, Stage, plain_bob_lead_head};
///
/// let a_group_lead_head = plain_bob_lead_head(Stage::MAJOR, 1);
/// let b_group_lead_head = plain_bob_lead_head(Stage::MAJOR, 2);
///
/// let mut accum = ChangeAccumulator::new(Stage::MAJOR);
///
/// assert_eq!(accum.total(), &Change::rounds(Stage::MAJOR));
/// assert_eq!(accum.last(), &Change::rounds(Stage::MAJOR));
///
/// accum.accumulate(&a_group_lead_head);
/// accum.accumulate(&a_group_lead_head);
///
/// // Two leads of an a-group method = one lead of a b-group method
/// assert_eq!(accum.total(), &b_group_lead_head);
/// assert_eq!(accum.last(), &a_group_lead_head);
///
/// // Undo a change's effect
/// accum.accumulate_inverse(&a_group_lead_head);
///
/// assert_eq!(accum.total(), &a_group_lead_head);
///
/// accum.reset();
///
/// assert_eq!(accum.total(), &Change::rounds(Stage::MAJOR));
/// ```
pub struct ChangeAccumulator {
    change_1: Change,
    change_2: Change,
    stage: Stage,
    using_second_change: bool,
}

impl ChangeAccumulator {
    /// Creates a new `ChangeAccumulator` with rounds as the total.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let accum = ChangeAccumulator::new(Stage::CINQUES);
    ///
    /// assert_eq!(accum.total(), &Change::rounds(Stage::CINQUES));
    /// assert_eq!(accum.last(), &Change::rounds(Stage::CINQUES));
    /// ```
    pub fn new(stage: Stage) -> ChangeAccumulator {
        ChangeAccumulator {
            change_1: Change::rounds(stage),
            change_2: Change::rounds(stage),
            stage,
            using_second_change: false,
        }
    }

    /// Returns the last value to be stored in the `ChangeAccumulator`, or rounds if one or fewer
    /// changes have been accumulated.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::ROYAL);
    ///
    /// // After one accumulate, the last value is still rounds
    /// accum.accumulate(&Change::from("5678901234"));
    /// assert_eq!(accum.last(), &Change::rounds(Stage::ROYAL));
    ///
    /// // After the second accumulate, the last value is the first change
    /// accum.accumulate(&Change::from("0987123456"));
    /// assert_eq!(accum.last(), &Change::from("5678901234"));
    ///
    /// accum.reset();
    ///
    /// // After resetting, the last value is set back to rounds
    /// assert_eq!(accum.last(), &Change::rounds(Stage::ROYAL));
    /// ```
    pub fn last(&self) -> &Change {
        // Return the 'back' buffered change - i.e. the one that isn't the total
        if self.using_second_change {
            &(self.change_1)
        } else {
            &(self.change_2)
        }
    }

    /// Returns the current value of the accumulator, representing the 'total' of all the `Change`s
    /// accumulated so far.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage, plain_bob_lead_head};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::MAJOR);
    ///
    /// // No changes have been accumulated, so the total is the identity permutation, or rounds
    /// assert_eq!(accum.total(), &Change::rounds(Stage::MAJOR));
    ///
    /// // Accumulate some leads (like in Pipe-style cyclic spliced)
    /// accum.accumulate(&plain_bob_lead_head(Stage::MAJOR, 1));
    /// accum.accumulate(&plain_bob_lead_head(Stage::MAJOR, -2));
    /// accum.accumulate(&plain_bob_lead_head(Stage::MAJOR, 3));
    ///
    /// // The total should be 2nd lead head of plain bob
    /// assert_eq!(accum.total(), &plain_bob_lead_head(Stage::MAJOR, 2));
    ///
    /// // Now, let's pre-accumulate a cyclic part head.  This will be as though that part head
    /// // took effect before all the other changes.
    /// accum.pre_accumulate(&Change::from("45678123"));
    ///
    /// // The change has been rotated so that the 4 is the hunt bell
    /// assert_eq!(accum.total(), &Change::from("48263517"));
    /// ```
    pub fn total(&self) -> &Change {
        // Return the 'front' buffered change
        if self.using_second_change {
            &(self.change_2)
        } else {
            &(self.change_1)
        }
    }

    /// Accumulate an [Iterator] representing a permutation onto the accumulator.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Bell, Change, ChangeAccumulator, Stage};
    ///
    /// // An array of Bells representing the change '1342'
    /// let bells = [Bell::from('1'), Bell::from('3'), Bell::from('4'), Bell::from('2')];
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::MINIMUS);
    ///
    /// accum.accumulate_iterator(bells.iter().map(|x| Bell::from(*x)));
    /// accum.accumulate_iterator(bells.iter().map(|x| Bell::from(*x)));
    ///
    /// // '1342' applied twice makes '1423'
    /// assert_eq!(accum.total(), &Change::from("1423"));
    /// ```
    pub fn accumulate_iterator(&mut self, iterator: impl Iterator<Item = Bell>) {
        // We can't inline this if statement, because doing so would require us to clone the
        // Change or anger the borrow checker.
        if self.using_second_change {
            self.change_2
                .multiply_iterator_into(iterator, &mut self.change_1);
        } else {
            self.change_1
                .multiply_iterator_into(iterator, &mut self.change_2);
        }

        // Swap the buffers so that the result is in the 'front' buffer
        self.using_second_change = !self.using_second_change;
    }

    /// Accumulate a [Transposition] into the accumulator.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::MAXIMUS);
    ///
    /// // First let's accumulate a cyclic part head
    /// accum.accumulate(&Change::from("567890ET1234"));
    ///
    /// // And now let's accumulate a change that we might find in that part
    /// accum.accumulate(&Change::from("5432167890ET"));
    ///
    /// // And the total is a cyclically rotated version of the 5432167890ET:
    /// assert_eq!(accum.total(), &Change::from("987650ET1234"));
    /// ```
    pub fn accumulate(&mut self, transposition: &impl Transposition) {
        // We can't inline this if statement, because doing so would require us to clone the
        // Change or anger the borrow checker.
        if self.using_second_change {
            self.change_2
                .multiply_into(transposition, &mut self.change_1);
        } else {
            self.change_1
                .multiply_into(transposition, &mut self.change_2);
        }

        // Swap the buffers so that the result is in the 'front' buffer
        self.using_second_change = !self.using_second_change;
    }

    /// Accumulate the inverse of a [Transposition] into the accumulator, without storing that
    /// inverse in memory.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::MAJOR);
    ///
    /// let arbitrary_change = Change::from("65812437");
    ///
    /// // Accumulate an arbitrary_change and its inverse, ...
    /// accum.accumulate(&arbitrary_change);
    /// accum.accumulate_inverse(&arbitrary_change);
    ///
    /// // ... and the result should be rounds, since the effect of the two changes cancel out
    /// assert_eq!(accum.total(), &Change::rounds(Stage::MAJOR));
    pub fn accumulate_inverse(&mut self, transposition: &impl Transposition) {
        // We can't inline this if statement, because doing so would require us to clone the
        // Change or anger the borrow checker.
        if self.using_second_change {
            self.change_2
                .multiply_inverse_into(transposition, &mut self.change_1);
        } else {
            self.change_1
                .multiply_inverse_into(transposition, &mut self.change_2);
        }

        // Swap the buffers so that the result is in the 'front' buffer
        self.using_second_change = !self.using_second_change;
    }

    /// Accumulate a [Transposition] into the accumulator, but premultiply it instead of
    /// postmultiplying like you usually would.  In ringing terms, this has the effect of the
    /// [Transposition] being rung **before** all the other [Transposition]s already accumulated.
    /// Useful for tasks like adding a part-head to a [Change] you've already calculated.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::ROYAL);
    ///
    /// // Accumulate a change that we might find in the plain course of a musical method
    /// accum.accumulate(&Change::from("5124367890"));
    ///
    /// // Pre-accumulate a cyclic part head to find out what that change would be in that
    /// // particular part
    /// accum.pre_accumulate(&Change::from("1678902345"));
    ///
    /// assert_eq!(accum.total(), &Change::from("9168702345"));
    /// ```
    pub fn pre_accumulate(&mut self, transposition: &impl Transposition) {
        // We can't inline this if statement, because doing so would require us to clone the
        // Change or anger the borrow checker.
        if self.using_second_change {
            self.change_2
                .pre_multiply_into(transposition, &mut self.change_1);
        } else {
            self.change_1
                .pre_multiply_into(transposition, &mut self.change_2);
        }

        // Swap the buffers so that the result is in the 'front' buffer
        self.using_second_change = !self.using_second_change;
    }

    /// The accumulator total to a specific [Transposition].  Note that this leaves the
    /// [last](ChangeAccumulator::last) value untouched.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::MAJOR);
    ///
    /// let arbitrary_change = Change::from("71526348");
    /// let queens = Change::from("13572468");
    ///
    /// // Accumulate a load of changes to the accumulator
    /// accum.accumulate(&arbitrary_change);
    /// accum.accumulate(&arbitrary_change);
    /// accum.accumulate(&arbitrary_change);
    ///
    /// assert_eq!(accum.total(), &arbitrary_change.pow(3));
    ///
    /// // Set a specific change (in this case Queens)
    /// accum.set(&queens);
    ///
    /// assert_eq!(accum.total(), &queens);
    /// assert_ne!(accum.total(), &arbitrary_change.pow(3));
    /// ```
    pub fn set(&mut self, transposition: &impl Transposition) {
        if self.stage != transposition.stage() {
            panic!("Can't write a change of the wrong stage into accumulator");
        }

        let slice = transposition.slice();

        if self.using_second_change {
            for i in 0..self.stage.as_usize() {
                self.change_2.seq[i] = slice[i];
            }
        } else {
            for i in 0..self.stage.as_usize() {
                self.change_1.seq[i] = slice[i];
            }
        }
    }

    /// Reset both buffers in the [ChangeAccumulator] to rounds.
    ///
    /// # Example
    /// ```
    /// use bellmetal::{Change, ChangeAccumulator, Stage};
    ///
    /// let mut accum = ChangeAccumulator::new(Stage::MAJOR);
    ///
    /// let arbitrary_change = Change::from("56817423");
    ///
    /// // Accumulate a load of changes to the accumulator
    /// accum.accumulate(&arbitrary_change);
    /// accum.accumulate(&arbitrary_change);
    /// accum.accumulate(&arbitrary_change);
    ///
    /// // Demonstrate that the total is something other than rounds
    /// assert_ne!(accum.total(), &Change::rounds(Stage::MAJOR));
    ///
    /// // Reset the accumulator, and assert that the total is now rounds.
    /// accum.reset();
    ///
    /// assert_eq!(accum.total(), &Change::rounds(Stage::MAJOR));
    /// ```
    pub fn reset(&mut self) {
        for i in 0..self.stage.as_usize() {
            self.change_1.seq[i] = Bell::from(i);
            self.change_2.seq[i] = Bell::from(i);

            self.using_second_change = false;
        }
    }
}

/// An iterator adapter that converts an [Iterator] of [Bell]s into an [Iterator] of [Change]s.  If
/// the [Iterator] stops half way through a [Change], that final [Change] is disregarded, and the
/// [ChangeCollectIter] stops too.
///
/// # Example
/// ```
/// use bellmetal::{Change, ChangeCollectIter, Stage, Transposition};
///
/// // Make a bell iterator that contains the first half of Plain Hunt Minimus, plus some leftover
/// // bells
/// let list_of_bells = Change::from("12342143241342314321666");
/// let bell_iter = list_of_bells.slice().iter().copied();
///
/// let mut collected_iter = ChangeCollectIter::new(bell_iter, Stage::MINIMUS);
///
/// assert_eq!(collected_iter.next(), Some(Change::from("1234")));
/// assert_eq!(collected_iter.next(), Some(Change::from("2143")));
/// assert_eq!(collected_iter.next(), Some(Change::from("2413")));
/// assert_eq!(collected_iter.next(), Some(Change::from("4231")));
/// assert_eq!(collected_iter.next(), Some(Change::from("4321")));
/// assert_eq!(collected_iter.next(), None);
/// ```
pub struct ChangeCollectIter<T: Iterator<Item = Bell>> {
    bell_iter: T,
    stage: Stage,
}

impl<T: Iterator<Item = Bell>> ChangeCollectIter<T> {
    /// Creates a new `ChangeCollectIter` from any [Iterator] of [Bell]s.
    ///
    /// See the example for the [ChangeCollectIter] class.
    pub fn new(bell_iter: T, stage: Stage) -> ChangeCollectIter<T> {
        ChangeCollectIter {
            bell_iter,
            stage,
        }
    }
}

impl<T: Iterator<Item = Bell>> Iterator for ChangeCollectIter<T> {
    type Item = Change;

    fn next(&mut self) -> Option<Change> {
        let stage = self.stage.as_usize();
        let mut vec: Vec<Bell> = Vec::with_capacity(stage);

        for _ in 0..stage {
            if let Some(b) = self.bell_iter.next() {
                vec.push(b);
            } else {
                return None;
            }
        }

        Some(Change::new(vec))
    }
}

#[cfg(test)]
mod tests {
    use crate::{Bell, Change, Parity, Place, Stage, Transposition};

    use crate::utils::ExtentIterator;

    use std::fmt::Write;

    #[test]
    fn equality() {
        assert!(
            Change {
                seq: vec![Bell::from(1), Bell::from(0), Bell::from(3), Bell::from(2)]
            } == Change {
                seq: vec![Bell::from(1), Bell::from(0), Bell::from(3), Bell::from(2)]
            }
        );

        // Different bells
        assert!(
            Change {
                seq: vec![Bell::from(1), Bell::from(0), Bell::from(2), Bell::from(3)]
            } != Change {
                seq: vec![Bell::from(1), Bell::from(0), Bell::from(3), Bell::from(2)]
            }
        );

        // Different stage
        assert!(
            Change {
                seq: vec![
                    Bell::from(1),
                    Bell::from(0),
                    Bell::from(3),
                    Bell::from(2),
                    Bell::from(4)
                ]
            } != Change {
                seq: vec![Bell::from(1), Bell::from(0), Bell::from(3), Bell::from(2)]
            }
        );
    }

    #[test]
    fn from_string() {
        // Different bells
        assert_eq!(
            Change::from("2143"),
            Change {
                seq: vec![Bell::from(1), Bell::from(0), Bell::from(3), Bell::from(2)]
            }
        );
        assert_eq!(Change::from(""), Change { seq: vec![] });
    }

    #[test]
    #[should_panic]
    fn from_string_illegal_bell() {
        Change::from("2134 ");
    }

    #[test]
    fn stage() {
        assert_eq!(Stage::from(0), Change::from("").stage());
        assert_eq!(Stage::from(1), Change::from("1").stage());
        assert_eq!(Stage::from(10), Change::from("6789052431").stage());
    }

    #[test]
    fn parity() {
        assert_eq!(Parity::Even, Change::from("1234567").parity());
        assert_eq!(Parity::Even, Change::from("87654321").parity());
        assert_eq!(Parity::Even, Change::from("13425678").parity());

        assert_eq!(Parity::Odd, Change::from("1234657").parity());
        assert_eq!(Parity::Odd, Change::from("2143657890").parity());
        assert_eq!(Parity::Odd, Change::from("7654321").parity());
    }

    #[test]
    fn copy_into() {
        let mut change = Change::empty();

        for c in &[
            Change::from("1234"),
            Change::from(""),
            Change::from("17342685"),
            Change::from("85672341"),
            Change::from("0987123456"),
            Change::from(""),
        ] {
            c.copy_into(&mut change);

            assert_eq!(*c, change);
        }
    }

    #[test]
    fn multiplication() {
        let changes = [
            (
                Change::from("1324"),
                Change::from("4231"),
                Change::from("4321"),
            ),
            (
                Change::from("13425678"),
                Change::from("13425678"),
                Change::from("14235678"),
            ),
            (
                Change::from("543216"),
                Change::from("543216"),
                Change::from("123456"),
            ),
            (
                Change::from("132546"),
                Change::from("123546"),
                Change::from("132456"),
            ),
        ];

        for (lhs, rhs, result) in &changes {
            assert_eq!(lhs.clone() * rhs.clone(), *result);

            assert_eq!(lhs.multiply(rhs), *result);
            assert_eq!(lhs.multiply_iterator(rhs.iter()), *result);
        }
    }

    #[test]
    fn multiply_into() {
        let mut change = Change::rounds(Stage::MAJOR);

        Change::from("15678234").multiply_into(&Change::from("13456782"), &mut change);
        assert_eq!(change, Change::from("16782345"));

        Change::from("15678234").multiply_into(&Change::from("87654321"), &mut change);
        assert_eq!(change, Change::from("43287651"));
    }

    #[test]
    fn multiply_inverse_into() {
        let mut change = Change::empty();

        Change::from("15678234").multiply_inverse_into(&Change::from("18234567"), &mut change);
        assert_eq!(change, Change::from("16782345"));

        Change::from("15678234").multiply_inverse_into(&Change::from("87654321"), &mut change);
        assert_eq!(change, Change::from("43287651"));
    }

    #[test]
    fn exponentiation() {
        assert_eq!(
            Change::from("18765432").pow(2),
            Change::rounds(Stage::from(8))
        );
        assert_eq!(
            Change::from("81275643").pow(0),
            Change::rounds(Stage::from(8))
        );
        assert_eq!(Change::from("912345678").pow(-4), Change::from("567891234"));
        assert_eq!(Change::from("134265").pow(2), Change::from("142356"));
        assert_eq!(Change::from("134265").pow(-3), Change::from("123465"));
    }

    #[test]
    #[should_panic]
    fn multiplication_nonequal_stages() {
        let _ = Change::from("1234") * Change::from("12345");
    }

    #[test]
    #[should_panic]
    fn multiplicaty_invert_nonequal_stages() {
        Change::from("1234").multiply_inverse_into(&Change::from("12345"), &mut Change::empty());
    }

    #[test]
    #[should_panic]
    fn pre_multiplication_into_nonequal_stages_1() {
        Change::from("1234").pre_multiply_into(&Change::from("12345"), &mut Change::empty());
    }

    #[test]
    fn pre_multiplication_into_nonequal_stages_2() {
        let mut c = Change::empty();

        Change::from("32145678").pre_multiply_into(&Change::from("78123456"), &mut c);

        assert_eq!(c, Change::from("18723456"));
    }

    #[test]
    fn mut_slice() {
        let mut c = Change::rounds(Stage::MAXIMUS);

        c.mut_slice()[5] = Bell::from(0);

        assert_eq!(c, Change::from("1234517890ET"));
    }

    #[test]
    fn inversion() {
        assert_eq!(!Change::from("12345"), Change::from("12345"));
        assert_eq!(!Change::from("1235647890"), Change::from("1236457890"));
        assert_eq!(!Change::from("654321"), Change::from("654321"));
    }

    #[test]
    fn iterators() {
        let changes = vec![
            Change::from("12345"),
            Change::from("7298324516"),
            Change::from(""),
            Change::from("0987123456"),
        ];

        for c in changes {
            let mut x = 0;

            for b in c.iter() {
                assert_eq!(b, c.bell_at(Place::from(x)));

                x += 1;
            }
        }
    }

    #[test]
    fn cyclicness_tests() {
        assert!(Change::from("12345").is_full_cyclic());
        assert!(Change::from("5678901234").is_full_cyclic());
        assert!(!Change::from("42513").is_full_cyclic());
        assert!(!Change::from("14567234").is_full_cyclic());

        assert!(Change::from("54321").is_reverse_full_cyclic());
        assert!(Change::from("7654321098").is_reverse_full_cyclic());
        assert!(!Change::from("42513").is_reverse_full_cyclic());
        assert!(!Change::from("14567234").is_reverse_full_cyclic());

        assert!(Change::from("123456789").is_fixed_treble_cyclic());
        assert!(Change::from("134562").is_fixed_treble_cyclic());
        assert!(!Change::from("4567123").is_fixed_treble_cyclic());
        assert!(!Change::from("42513").is_fixed_treble_cyclic());

        assert!(Change::from("198765432").is_reverse_fixed_treble_cyclic());
        assert!(Change::from("126543").is_reverse_fixed_treble_cyclic());
        assert!(!Change::from("4567123").is_reverse_fixed_treble_cyclic());
        assert!(!Change::from("3217654").is_reverse_fixed_treble_cyclic());
        assert!(!Change::from("42513").is_reverse_fixed_treble_cyclic());
    }

    #[test]
    fn backrounds_test() {
        assert!(Change::from("4321").is_backrounds());
        assert!(Change::from("1").is_backrounds());
        assert!(Change::from("").is_backrounds());
        assert!(!Change::from("7584012369").is_backrounds());
        assert!(!Change::from("4567123").is_backrounds());
    }

    #[test]
    fn rounds_test() {
        assert!(Change::from("1234567890E").is_rounds());
        assert!(Change::from("1").is_rounds());
        assert!(Change::from("").is_rounds());
        assert!(!Change::from("7584012369").is_rounds());
        assert!(!Change::from("4567123").is_rounds());
    }

    #[test]
    fn music_run_lengths() {
        assert_eq!(Change::from("14238765").run_length_off_front(), 1);
        assert_eq!(Change::from("12346578").run_length_off_front(), 4);
        assert_eq!(Change::from("12345678").run_length_off_front(), 8);
        assert_eq!(Change::from("76543218").run_length_off_front(), 7);

        assert_eq!(Change::from("81765432").run_length_off_back(), 6);
        assert_eq!(Change::from("14238765").run_length_off_back(), 4);
        assert_eq!(Change::from("76543218").run_length_off_back(), 1);
        assert_eq!(Change::from("1234567890").run_length_off_back(), 10);
    }

    #[test]
    fn in_place_inverse() {
        for (from, to) in &[
            ("1", "1"),
            ("4231", "1324"),
            ("14235", "52431"),
            ("12345678", "87654321"),
        ] {
            let mut change = Change::from(*from);

            change.in_place_inverse();

            assert_eq!(change, Change::from(*to));
        }
    }

    #[test]
    fn in_place_fixed_treble_cyclic_rotate() {
        for (from, amount, to) in &[
            ("1", 5, "1"),
            ("12345", 3, "15234"),
            ("43215678", 6, "32814567"),
            ("1425367890", 5, "1970823456"),
            ("1425367890", 14, "1970823456"),
        ] {
            let mut change = Change::from(*from);

            change.in_place_fixed_treble_cyclic_rotate(*amount);

            assert_eq!(change, Change::from(*to));
        }
    }

    #[test]
    fn in_place_full_cyclic_rotate() {
        for (from, amount, to) in &[
            ("1", 5, "1"),
            ("12345", 3, "45123"),
            ("43215678", 6, "21873456"),
            ("1425367890", 5, "6970812345"),
        ] {
            let mut change = Change::from(*from);

            change.in_place_full_cyclic_rotate(*amount);

            assert_eq!(change, Change::from(*to));
        }
    }

    #[test]
    fn in_place_fixed_treble_inverse() {
        for (from, to) in &[
            ("1", "1"),
            ("4231", "2431"),
            ("14235", "13542"),
            ("12345678", "18765432"),
        ] {
            let mut change = Change::from(*from);

            change.in_place_fixed_treble_inverse();

            assert_eq!(change, Change::from(*to));
        }
    }

    #[test]
    fn in_place_reverse() {
        for s in &["1", "4231", "14235", "12345678"] {
            let mut change = Change::from(*s);

            change.in_place_reverse();

            assert_eq!(
                change,
                Change::from(&s.chars().rev().collect::<String>()[..])
            );
        }
    }

    #[test]
    fn destructive_hash() {
        for s in 1..=8 {
            let mut hashes: Vec<usize> = ExtentIterator::new(Stage::from(s))
                .map(|mut x| x.destructive_hash())
                .collect();

            hashes.sort();

            // Assert that the sorted hashes are precisely the numbers from 0 to (stage! - 1)
            for s in 0..hashes.len() {
                assert_eq!(hashes[s], s);
            }
        }
    }

    #[test]
    fn debug_print() {
        let mut s = String::with_capacity(20);

        write!(&mut s, "{:?}", Change::from("")).unwrap();
        assert_eq!(s, "<>");
        s.clear();

        write!(&mut s, "{:?}", Change::from("14325")).unwrap();
        assert_eq!(s, "<14325>");
        s.clear();

        write!(&mut s, "{:?}", Change::from("1678902345ET")).unwrap();
        assert_eq!(s, "<1678902345ET>");
        s.clear();
    }
}

#[cfg(test)]
mod accumulator_tests {
    use crate::{Change, ChangeAccumulator, Stage};

    #[test]
    #[should_panic]
    fn set_wrong_stage() {
        let mut acc = ChangeAccumulator::new(Stage::MAJOR);

        acc.set(&Change::from("123"));
    }

    #[test]
    fn non_panicking_behaviour() {
        let mut acc = ChangeAccumulator::new(Stage::MAJOR);

        assert_eq!(acc.total(), &Change::rounds(Stage::MAJOR));

        acc.accumulate(&Change::from("43215678"));
        assert_eq!(acc.total(), &Change::from("43215678"));
        acc.accumulate(&Change::from("43215678"));
        assert_eq!(acc.total(), &Change::from("12345678"));

        acc.accumulate(&Change::from("34567812"));
        assert_eq!(acc.total(), &Change::from("34567812"));
        acc.accumulate(&Change::from("34567812"));
        assert_eq!(acc.total(), &Change::from("56781234"));

        acc.accumulate_inverse(&Change::from("31245678"));
        assert_eq!(acc.total(), &Change::from("67581234"));

        acc.pre_accumulate(&Change::from("81234567"));
        assert_eq!(acc.total(), &Change::from("56478123"));
        acc.pre_accumulate(&Change::from("45678123"));
        assert_eq!(acc.total(), &Change::from("81723456"));

        acc.set(&Change::from("74651238"));
        assert_eq!(acc.total(), &Change::from("74651238"));

        acc.pre_accumulate(&Change::from("45678123"));
        assert_eq!(acc.total(), &Change::from("27184563"));

        acc.set(&Change::from("74865123"));
        assert_eq!(acc.total(), &Change::from("74865123"));

        acc.reset();
        assert_eq!(acc.total(), &Change::rounds(Stage::MAJOR));
    }
}

#[cfg(test)]
mod collection_tests {
    use crate::{Change, ChangeCollectIter, Stage, Transposition};

    #[test]
    fn normal_usage() {
        let c = Change::from("123452143524153425134523154321");

        let mut iter = ChangeCollectIter::new(c.iter(), Stage::DOUBLES);

        assert_eq!(iter.next(), Some(Change::from("12345")));
        assert_eq!(iter.next(), Some(Change::from("21435")));
        assert_eq!(iter.next(), Some(Change::from("24153")));
        assert_eq!(iter.next(), Some(Change::from("42513")));
        assert_eq!(iter.next(), Some(Change::from("45231")));
        assert_eq!(iter.next(), Some(Change::from("54321")));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn incorrect_length() {
        let c = Change::from("1234521435241534251345231543214523");

        let mut iter = ChangeCollectIter::new(c.iter(), Stage::DOUBLES);

        assert_eq!(iter.next(), Some(Change::from("12345")));
        assert_eq!(iter.next(), Some(Change::from("21435")));
        assert_eq!(iter.next(), Some(Change::from("24153")));
        assert_eq!(iter.next(), Some(Change::from("42513")));
        assert_eq!(iter.next(), Some(Change::from("45231")));
        assert_eq!(iter.next(), Some(Change::from("54321")));
        assert_eq!(iter.next(), None);
    }
}
